package pkg

import (
	"bytes"
	"crypto/sha1"
	"fmt"
	"go/types"
	"sort"
	"strings"
	"time"

	"github.com/kasiss-liu/easyvalid/lexer"
	"golang.org/x/tools/go/packages"
)

const (
	delimiter         = ";"
	unexportNameRule  = "valid_%s_%s" //属性验证方法名称规则 非导出
	exportNameRule    = "Valid_%s_%s" //属性验证方法名称规则 导出
	defaultStNameRule = "EasyValid"   //验证入口方法名
)

var (
	indent  = strings.Repeat(" ", 4)    //1个缩进单元
	indent2 = strings.Repeat(indent, 2) //2个缩进单元
	rt      = "\n"                      //换行符
	rt2     = strings.Repeat(rt, 2)     //2换行符
)

var extraImports = []string{"errors"}

//SetExtraImport 如果需要valid函数是可导出状态
func SetExtraImport(i string) {
	extraImports = append(extraImports, i)
}

//Generator 文件生成器
type Generator struct {
	pkg          *packages.Package      //需要的包信息
	packageName  string                 //包名称
	buildTags    string                 //需要写入的build tags
	note         string                 //需要写入的其他说明
	imports      []*packages.Package    //解析后的import列表
	usedImports  []*packages.Package    //使用到的import列表
	structs      []*Structure           //需要生成的struct列表
	buf          bytes.Buffer           //内容缓存
	validItems   map[string][]validItem //解析后，记录需要生成验证的元素信息
	funcExported bool                   //验证方法是否可导出
	funcNameRule string                 //属性验证方法名称规则
	stNameRule   string                 //验证入口方法名
}

//SetNote 外部设置说明信息
func (g *Generator) SetNote(note string) {
	g.note = note
}

//SetBuildTags 外部设置构建标签
func (g *Generator) SetBuildTags(buildTags string) {
	g.buildTags = buildTags
}

//SetValidFuncExport 设置是否需要方法名导出
func (g *Generator) SetValidFuncExport(e bool) {
	g.funcExported = e
	if e {
		g.funcNameRule = exportNameRule
	} else {
		g.funcNameRule = unexportNameRule
	}
}

//printf  向内容缓存区打印文件内容
func (g *Generator) printf(exp string, vals ...interface{}) {
	fmt.Fprintf(&g.buf, exp, vals...)
}

//GetPrintBuf 获取文件内容
func (g *Generator) GetPrintBuf() bytes.Buffer {
	return g.buf
}

//Run 生成文件内容
func (g *Generator) Run() error {
	g.GenerateHeader()
	g.GeneratePkg()
	g.GenerateImportsFlag()
	err := g.GenerateStructuresValid()
	if err != nil {
		return err
	}
	g.GenerateImports()
	return nil
}

//GenerateHeader 打印文件头部
func (g *Generator) GenerateHeader() {

	if g.buildTags != "" {
		g.printf("// +build %s"+rt, g.buildTags)
	}
	g.printf("// Code generated by %s %s . DO NOT EDIT.\n", PackageName, Version)
	if g.note != "" {
		g.printf(rt)
		for _, n := range strings.Split(g.note, "\\n") {
			g.printf("// %s"+rt, n)
		}
	}
	g.printf(rt)
}

//GeneratePkg 打印package名称
func (g *Generator) GeneratePkg() {
	g.printf("package %s"+rt2, g.pkg.Name)
}

//GenerateImportsFlag 打印import
func (g *Generator) GenerateImportsFlag() {
	g.printf("%s", "{%import%}")
}

//GenerateImports 打印import
func (g *Generator) GenerateImports() {
	imports := make(sortableStrings, 0)
	uniqImports := make(map[string]interface{})
	for _, v := range g.usedImports {
		imports = append(imports, v.ID)
		uniqImports[v.ID] = nil
	}
	//验证方法会使用到errors包 提前写入
	//TODO 注入外部需求的包内容
	for _, imt := range extraImports {
		if _, ok := uniqImports[imt]; !ok {
			imports = append(imports, imt)
		}
	}
	sort.Sort(imports)
	importStr := ""
	importStr += "import"
	importStr += " (" + rt
	for _, i := range imports {
		importStr += fmt.Sprintf("    \"%s\""+rt, i)
	}
	importStr += ")" + rt2
	buf := bytes.Replace(g.buf.Bytes(), []byte("{%import%}"), []byte(importStr), 1)
	g.buf.Reset()
	g.buf.Write(buf)
}

//GenerateStructuresValid 生成结构体的验证内容
func (g *Generator) GenerateStructuresValid() (err error) {
	for _, s := range g.structs {
		g.generateStructureValid(s)
		err = g.generateFieldValid(s)
		if err != nil {
			return
		}
	}
	return nil
}

//generateStructureValid 生成验证入口方法
//example:
//func (e example) EasyValid() error {
//	if err := e.valid_xxxx_attr1; err != nil { return err }
//}
func (g *Generator) generateStructureValid(s *Structure) {

	g.printf(g.generateStructValidName(s.Alias, s.Name))
	g.printf(" {" + rt)
	sha1Name := createSha1(s.Name)
	validNum := 0
	validItems := make([]validItem, 0)
	for i := 0; i < s.Struct.NumFields(); i++ {
		fieldName := s.Struct.Field(i).Name()
		funcName := fmt.Sprintf(g.funcNameRule, sha1Name, fieldName)
		msg, needValid := s.GetTag(i, ValidFlag)
		if needValid {
			validItems = append(validItems, validItem{
				pkgName:  s.Name,
				funcName: funcName,
				validMsg: msg,
				st:       s.Struct,
				index:    i,
			})
			validNum++
			g.printf("%sif err = %s.%s(); err != nil {"+rt+"%sreturn"+rt+"%s}"+rt, indent, s.Alias, funcName, indent2, indent)
		}
	}
	g.validItems[s.Name] = validItems
	g.printf("    return nil" + rt + "}" + rt)
}

//generateStructValidName 生成验证方法入口行
func (g *Generator) generateStructValidName(alias, name string) string {
	return fmt.Sprintf("func (%s %s) "+g.stNameRule+" () (err error)", alias, name)
}

//generateFieldValid 生成具体的属性验证方法
//example:
//func (e example) valid_xxxx_attr1() error {
//	if len(e.attr1) == 0 { return errors.New("len invalid") }
//}
func (g *Generator) generateFieldValid(s *Structure) (err error) {

	validItems, ok := g.validItems[s.Name]
	if !ok {
		return
	}
	for _, f := range validItems {
		g.printf("func (%s %s) %s() (err error)", s.Alias, f.pkgName, f.funcName)
		g.printf(" {" + rt)
		//解析msg
		var vs []lexer.IValidator
		fieldName := f.st.Field(f.index).Name()
		vs, err = g.splitValidMsg(f.validMsg, delimiter, s.Alias, f.st.Field(f.index))
		if err != nil {
			err = fmt.Errorf(err.Error(), f.pkgName, fieldName)
			return
		}
		for _, fn := range vs {
			fn.SetIndent(indent)
			fn.SetReturn(rt)
			g.printf(fn.GenCode())
		}

		g.printf("%sreturn nil"+rt+"}"+rt2, indent)
	}
	return
}

//splitValidMsg 解析结构体 tag内容 返回用于生成验证内容的gen方法
func (g *Generator) splitValidMsg(msg, delimiter, pointerAlias string, field *types.Var) ([]lexer.IValidator, error) {
	lex := lexer.NewLexer(msg, delimiter, pointerAlias, field)
	lex.SetImports(g.imports)
	var err error
	var vs []lexer.IValidator
	if err = lex.Parse(); err != nil {
		return nil, err
	}
	if vs, err = lex.GetValidatorList(); err != nil {
		return nil, err
	}
	g.usedImports = append(g.usedImports, lex.GetUsedImports()...)
	return vs, nil
}

//validItem 储存验证元素信息的结构体
//基于字段的tag 一个字段可能有多个validItem
type validItem struct {
	pkgName  string        //包命
	funcName string        //验证方法名
	validMsg string        //错误信息
	st       *types.Struct //字段所属结构体信息
	index    int           //字段在结构体中的索引
}

//createSha1 生成sha1字符串用于构建方法名 避免与原生方法命名冲突
func createSha1(s string) string {
	hash := sha1.New()
	hash.Write([]byte(fmt.Sprintf("%s%d", s, time.Now().UnixNano())))
	return fmt.Sprintf("%x", hash.Sum(nil))
}

//NewGenerator 获取一个生成器
func NewGenerator(pkg *packages.Package, structs []*Structure, imports []*packages.Package) *Generator {
	gen := &Generator{
		buf:          bytes.Buffer{},
		pkg:          pkg,
		structs:      structs,
		imports:      imports,
		validItems:   make(map[string][]validItem),
		stNameRule:   defaultStNameRule,
		funcNameRule: unexportNameRule,
		funcExported: false,
	}
	return gen
}

//sortableStructures 对获取到的结构体进行按字母排序
type sortableStrings []string

func (s sortableStrings) Len() int {
	return len(s)
}

func (s sortableStrings) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}

func (s sortableStrings) Less(i, j int) bool {
	return strings.Compare(s[i], s[j]) == -1
}
